# cp 02 language & grammar

符号 字母表 符号串 等定义，符号串的运算。

语法树，parsing tree。

文法规则的递归定义。

【重点】：文法和语言的关系。语言和文法互相转换，出题灵活。

对文法进行简化，无ε产生式。文法的二义性问题。

## language

### 基本概念

符号：symbol，语言中不可再分的单位。

字母表：alphabet，符号的非空有穷集合。

符号串：symbol string大概，某alphabet上symbol的有穷序列。

空串ε：不含任何符号的串。

语句：sentence，字母表上符合某种【构成规则】的符号串序列。

语言：language，某字母表上的句子的集合。

### 符号串集合的积 & 幂

符号串集合的积：

- 设A={a1, a2, ..., an}，B={b1, b2, ..., bm}，二者的笛卡尔积 AB={ab | a∈A, b∈B}。
- 比如，A={a, b}，B={c, e, d}，那么AB={ac, ae, ad, bc, be, bd}。

符号串集合的幂：

- $A^0$​​ = {ε}，$A^n$​​ = $AA^{n-1}$​​。
- 若|A|=m（A中元素个数），则$|A^0|=1$，$|A^n|$=$m^n$​。

### Kleene闭包 & 正闭包

Kleene闭包：$A^*=A^0\cup A\cup A^2\cup \cdots$；

正闭包：$A^+=A\cup A^2\cup \cdots=A^*-\{ε\}$；

## grammar

### 基本概念

文法：grammar，表达【语言，language】构成规则的形式化方法。

- 文法：$G=(V_N,V_T,S,P)$​；
- $V_N$​：非终结符集。能够放在产生式左部的符号。
- $V_T$​​：终结符集。只能放在产生式右部，到它就不能再产生了。
- S：文法开始符号。所有句子都要从【文法开始符号】开始推。
- P：产生式。<句子> -> <主语><谓语><宾语>，<主语> -> <名词>，<名词> ->men，就像这样。men是终结符。
- <形容词> -> young | pop，表示两个产生式。
- 这样一串以树形画出来，就是语法树，grammar tree。根节点就是文法开始符号，<句子>。

### deduction & reduction

推导：deduction，不断用产生式的右部（listen）取代左部（<动词>）的过程。

归约：reduction，deduction的逆过程，用产生式的左部取代右部的过程。

- 约定：最左/最右推导（每次dfs最左/最右那个节点）称为规范推导，最左/最右规约称为规范规约。
- 最【左】推导的逆过程是最【右】规约。不用多想，就是每一步按照顺序完全逆过来。

举个例子：

235，N -> D | ND，D -> 0|1|2|3|4|5|6|7|8|9。

最左推导：N -> ND -> NDD -> DDD -> 2DD -> 23D -> 235。

最右推导：N -> ND -> N5 -> ND5 -> N35 -> D35 -> 235。

可以画一个语法树parsing tree，注意parsing tree不要箭头。

### 文法规则的递归定义

句型：从文法开始符号S开始，每步推导（包括0步推导，即N本身）得到的字符串α，$\alpha \in (V_N\cup V_T)^*$​，*是kleene闭包。句型，如NDD、N35。

句子：仅含终结符的句型。

语言：由S推导所得的句子的集合，$L(G)=\{α|S\stackrel{+}{\longrightarrow}α,$​​ 且 $α\in V_T^*\}$​​​，G为文法。

文法规则的递归定义：非终结符的定义中包含了非终结符自身，如【N -> D|ND】。注意要有递归出口，否则永远产生不出句子（仅含终结符的句型）。

扩充的BNF表示（backus表示法，只是一些习惯表示，形式像正则表达式）：

- ()提因子，U -> ax | ay | az 改写为 U -> a (x|y|z)。
- {}重复次数的指定，<C++变量名> -> <字母>{<字母>|<数字>|<下划线>}。
- []任选符号，<整数> -> [+|-]<数字>{<数字>}。

## grammar & language的形式定义

重温：文法，是表达【语言，language】构成规则的形式化方法。$G=(V_N,V_T,S,P)$​。

### 文法类型

重点是23型文法。

#### chomsky 0型文法

短语文法，无限制文法。对产生式限制最少的文法。

P：α -> β，其中α∈V+并至少含有一个非终结符，β属于V*。

识别0型语言的自动机：图灵机（TM）。

#### chomsky 1型文法

长度增加文法，上下文有关文法。右部长度必须大于左部长度。

##### 定义1

P：α -> β，除S -> ε的情况均有|β|>=|α|。

如果有S -> ε，则S不能出现在产生式右部。即不能有人产生S，不然长度就缩小了。

##### 定义2

P中产生式除可能有S -> ε外，均为αAβ -> αγβ，其中α,β属于V*，A属于$V_N$，γ属于$V^+$。

- 对非终结符进行替换时，考虑上下文。
- 除文法开始符号外，不要选将其他的非终结符替换成ε。

识别1型语言的自动机：线性界限自动机（LBA）。

#### chomsky 2型文法

上下文无关文法，context free。

P：A -> β，其中A∈$V_N$，β∈V*。

产生式左部一定是非终结符，产生式右部可以是$V_N$、$V_T$、ε

识别2型语言的自动机：下推自动机（PDA）。

#### chomsky 3型文法

正规文法RG，线性文法。

形式：

- A -> αB，A -> α；
- A -> Bα，A -> α；

其中A,B属于$V_N$，α∈$V_T^*$​。

B在左边：左线性；B在右边：右线性。

（如果一会左边一会右边，就只能叫做2型文法而非3型文法。

识别3型语言的自动机：有限状态自动机（FSA）。

只允许出现一个非终结符。

### 由grammar产生language

grammar：【非终结符集，终结符集、文法开始符号、产生式】的四元组。

language：该grammar上句子的集合。

见ppt例题。

### 由language构造grammar

#### pattern：配比

a^{mi}b^{ni}，则S ->【m个a】S【n个b】|ε；

a^{i}b^{j}，i≥2j：也就是a的个数≥两倍b的个数，即生成一个b必须同时生成两个以上的a：S->aaSb，S->aaaSb。

这是我的想法，老师的想法如下：

S->AB, A->aA|ε, B->aaBb|ε。B负责按最低配比生成aab，A负责生成A比二倍B多的部分。注意≥，因此A要可以生成ε。这是一种分解的思想，T2B。

还有一种L2R的思想：

#### pattern：L2R

![image-20210812103346088](.\..\..\typora-user-images\image-20210812103346088.png)

S表示abc型，B表示bc型，C表示c型。

#### pattern：不要求对称的配比

L3={ω | ω∈(a,b)*}，且ω中含有相同个数的a和b。

进行复杂递归：

- S→ε，S→bB，S→aA。
- B是【b数目比a数目少一个】，A是【a数目比b数目少一个】。
- A→bS|b，A→aAA；B→aS|a，B→bBB。

另一种：

- S表示ab个数相同。
- S→aSbS；S→bSaS；S→ε。

#### pattern：奇偶性问题

要求串内1的个数为偶数。

- S是1个数为偶，A是1个数为奇。
- S→ε，S→0S，S→1A，A→0A，A→1S。
- 有点像状态转换图。状态机。

要求0的个数为奇，1的个数为偶。

- 4个状态：0奇1奇，0奇1偶，0偶1奇，0偶1偶。分别设为ABCD。
- S→B；D→ε。
- A→1B，A→0C；B→1A，B→0D；C→1D，C→0A；D→1C，D→0B；

##### 奇偶性问题的变式

以a开始以b结尾，a奇b偶。

仍然ABCD，S→aCb，C为a偶b奇。

### 文法简化

希望产生式的个数最少。

步骤：

- 删除形如P→P的产生式。
- 删除永不被使用的产生式，即由文法的开始符号无法推导出其左部。
- 删除不能从中导出终结符串的产生式。就是一直推来推去但没法结束。
- 整理产生式。

### 无ε产生式

使用对象是上下文无关的grammar。

- 若P中含S→ε，则S不出现在任何产生式右部，即S不能被推出来。S是文法的开始符号。
- P中不能有其他A→ε。

把所有能够直接/间接产生ε的非终结符找出来：先找到能一步推出ε的非终结符，然后把这些非终结符换成ε，再找能一步推出【这些非终结符】的非终结符……直到找不到新的非终结符。

如果grammar本来就能产生ε：添加一个新的文法开始符号。新开始符号→老开始符号，新开始符号→ε。这样就没人能推出新的开始符号了。

![image-20210817102726535](.\..\..\typora-user-images\image-20210817102726535.png)



## parsing tree & ambiguous

以下item了解即可：

- 子树：除叶结点外的任意结点连同它的所有子孙结点构成子树。子树的根节点不能是叶节点，也就是一定要是树。
- 修剪子树：剪去子树树根的所有子孙节点，对应于归约（一步或多步）。
- 句型：由树的末端符（叶结点）从左至右连成的串是文法的一个句型。
- 短语：【子树】的末端符号自左到右连成串， 相对于子树树根而言称为短语。
- 简单短语/直接短语：短语是某子树根经过1步deduction得到的。称之为【该子树根】的简单短语。
- 句型的短语：某句型中的短语（属于某子树）。
- 句柄：句型中的最左简单短语。是最左归约（最右推导的逆操作）时要寻找的简单短语。

### 二义性

不同的语法树推出相同的句子：二义性，ambiguous。

二义性不可判定：不存在这样一个算法，能够在有限步内判断一个文法是否为二义文法。

证明存在二义性：举一个例子就行了。















