# cp 07 runtime environment

## 概述

运行时存储分配策略：

- 静态存储分配，编译时可以完全确定数据对象大小，编译时就分配存储空间。
- 动态存储分配，编译时不能完全确定数据对象大小，编译时仅产生各种毕业信息，运行时动态分配存储空间。栈式存储分配，堆式存储分配。

运行时内存划分：

![image-20211125114525563](.\..\..\typora-user-images\image-20211125114525563.png)

活动 & 活动记录：

- 编译器以过程（函数、方法）危单位分配存储空间。
- 过程体的每次执行，称为该过程的一个活动。
- 对每个活动分配一块连续存储区，用来管理一次执行所需的信息，这块连续存储去称为活动记录。

![image-20211125150309408](.\..\..\typora-user-images\image-20211125150309408.png)

## 静态存储管理

- 【编译器】为每个过程确定活动记录的唯一存储位置。
- 这样，过程中每个名字的存储位置就确定了，每个名字的存储地址可以被编译到目标代码中，每次执行都绑定到同样的存储单元。
- 适用条件：
  - 数组上下界必须是常数；（没懂）
  - 不允许过程递归调用：不然不知道是哪个活动在使用存储位置。
  - 不允许动态建立数据实体：需要事先知道活动记录大小。
  - 满足这些条件的语言：BASIC、FORTRAN。

### 顺序分配法

![image-20211125151304600](.\..\..\typora-user-images\image-20211125151304600.png)

### 层次分配法

![image-20211125151321477](.\..\..\typora-user-images\image-20211125151321477.png)

不相互调用：记录不会同时存在。

算法：需要得到过程调用关系矩阵`B[n][n]`（`B[i][j]=1`表示 i 调用 j）和过程活动记录大小矩阵`Units[n]`。

## 栈式存储管理

过程调用时，活动记录压入栈；过程结束时，活动记录弹出栈。

非局部变量的相对地址总是固定的，和过程调用序列无关。

活动树：程序串行执行，父节点调用子节点，兄弟节点从左到右执行，我的左兄弟执行完我才能执行。

设计活动记录的原则：

![image-20211125152945060](.\..\..\typora-user-images\image-20211125152945060.png)

调用序列 & 返回序列：

- 过程的调用和返回，都需要执行一些代码，用来管理活动记录栈、保存或恢复机器状态等。
- 调用序列：实现过程调用的代码段。
  - 计算实参的值；
  - 将返回地址放到【被调用过程】的机器状态字段里；
  - 将原top-sp（调用我的函数的栈顶指针）放到【被调用过程】的控制链里；（SP大概是stack pointer，top则是栈顶指针，用来标记界限，超出top就栈溢出）
  - 令top-sp指向【被调用过程】局部数据开始的位置。
- 返回序列：恢复机器状态，保证调用结束后程序继续执行。
  - 恢复调用前的TOP；
  - 恢复调用前的SP；
  - 把返回地址取到X中；
  - 按X返回。

- 调用/返回序列的代码，被分割到到调用过程（调用者）和被调用过程（被调用者）中。

非嵌套过程语言还好说，但嵌套过程语言有一个问题：A过程里定义了B，B过程就可以访问【在A过程里定义的变量】了，B过程可以访问非局部变量。

每个变量的地址是层数+偏移量。我们需要所有外层过程的起始地址。

我们需要增加一个新的单元：静态链。

- 静态链指向我的外层活动地址。
- 动态链指向调用我的活动的地址。

究竟如何栈式内存管理？

详见国防科大 mooc 22.3节 第 3 个视频。

## 堆式存储管理

好像不做要求。

































