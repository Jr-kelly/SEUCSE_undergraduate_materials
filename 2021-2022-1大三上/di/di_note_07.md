# di 07 图像分割

图像分割目标：将像素分别标记为各个景物，一个像素的标记是且仅是一个景物，或者0.3景物A，0.7景物B，但加起来要=1。

核心问题：

- 特征空间，feature space：定义特征，将像素映射到特征空间的点，图像域→特征空间。
- 分类器，classifier：在特征空间里面设计一种分类的方法，将特征空间的样本分类为不同的集合。

## 特征提取，feature extraction

我们需要选择有效特征，significant features：类间的差异性，类内的相似性。

图像值（灰度/RGB），边界特征（高通滤波/梯度），纹理特征（texture）。

梯度的结果是向量，幅值：边界强度，方向：边界方向（法向量）。

边界：梯度方向连续且变化缓慢。

![image-20211129180116409](.\..\..\typora-user-images\image-20211129180116409.png)

还有laplacian。

LoG，laplacian of a gaussian：先高斯低通滤波，再过laplacian算子，减小微分算子对噪声的敏感性。

统计特征：直方图，矩moment，熵entropy。

## 分类器，classifier

输入特征，输出标签。

线性 / 非线性，01 / 模糊。

等价：面积分割 <=> 边界分割，性质好的区域 <=> 封闭边界。

分类误差：所有分类错的样本数量/总样本数量。

### 阈值法，thresholding

（不是灰度阈值法）

以二分类为例：1维特征空间，只需要确定一个阈值。2维特征空间，需要确定一条直线 $bt_1+a_t2-ab=0$，$D(t_1,t_2)=\frac{bt_1+a_t2-ab}{\sqrt{b^2+a^2}}$。

01分类：$g(x,y)=1$ if $D(\overrightarrow{t})>0$ else $0$。

模糊分类：（比如说）$g(x,y)=\frac1{1+e^{-D(t)}}$。

#### 确定阈值

拟合：

- 阈值=两个分布曲线的交点，可以得到最小分类误差。

- 如果不知道【两个分布】的具体曲线，只知道【总特征空间】的分布曲线，就认为是高斯分布（正态分布），然后我们用两个高斯函数来拟合【总特征空间】的分布曲线。
- 贝叶斯分类器：也需要知道两个曲线。

谷点阈值，valley thresholding：

- 采用驼峰的谷点。
- 关键步骤：直方图平滑（低通滤波），变成光滑的曲线。

大津阈值，otsu's thresholding method：

- 思想：方差代表了聚类的特性，方差越小，分布越密集。
- 最小化代价 $\sigma(T)=P_A(T)\sigma_A(T)+P_B(T)\sigma_B(T)$，PAPB是A类B类像素的先验出现概率，σ是划分类别的方差，如果不知道就都设成1。

最大熵阈值：（也有最小熵阈值）

- 一个分布的熵：$H(T)=-\int _{-\infin}^{\infin}p(t)\ln(p(t))dt$。聚类越好，熵越小。
- 最小熵：最小化这个函数：$\Psi(T)=H_A(T)+H_B(T)$，其中HAHB是熵，概率采用【该类里面某个特征值的像素个数 / 该类像素总共个数】。
- 最大熵：最大化上面那个函数。
  - 最大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。在这种情况下，概率分布最均匀，预测的风险最小。
  - 因为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。
  - 我们常说，不要把所有的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说法，因为当我们遇到不确定性时，就要保留各种可能性。说白了，就是要保留全部的不确定性，将风险降到最小。----摘自《Google黑板报》作者：吴军


### 区域增长

处理背景光不均匀的图像的思路：

- 一：均匀后，使用阈值法。
- 二：分成小块，认为小块内的背景光是均匀的，对每个小块使用阈值法。
- 分小块有一个问题：每个小块背景光不一样，边缘处的分类可能不一致。解决：让小块重叠，重叠部分的分类参考两边的小块（大概？）
- 或者：按马赛克的方法分块，对每个块得到阈值，按方位组成矩阵、进行平滑，这样就得到了图像的阈值图像，按阈值图像进行分割。
- 三：区域增长。

区域增长：

- 设置种子，用一个种子提取一个连通域；
- 定义一致性条件；
- 使用栈实现增长：
  - 1 初始种子入栈；
  - 2 从栈中弹出种子；
  - 3 标记种子点；
  - 4 遍历所有未标记邻点，判断邻点与种子点同类；
    - 是：压栈；
    - 否：继续；
  - 5 重复2-4，直到栈空。

需要一个一致性测度。“标准的串行算法”：可能是因为标记。

需要精细布置种子，每个块都要有一个。



