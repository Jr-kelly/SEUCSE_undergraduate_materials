# ds practice 框架

## 基本要求

实验报告：

1. 问题描述 / 需求分析：仔细分析实验要求，对实验内容进行需求分析；【题意】
2. 系统结构 / 算法思想：基本思路，系统框架，描述各模块功能及其关系；【模块化】或【思路】
3. 功能模块设计：模块设计思想、流程图、算法复杂度分析；【流程图】【模块图】【复杂度分析】
4. 测试结果与分析：测试数据选择或生成的方法，运行结果截图，性能图；【实验结果】
5. 实验总结：遇到的问题，问题的解决过程，总结实验心得体会；【总结的废话】
6. 源代码：项目所有源程序清单，应有充分的注释；【贴代码】

实验要求在第一次课回放 1h20min。

## 一、模拟矩阵相乘，实现最初版本的存储管理器

用文件模拟磁盘。假装自己有一个存储管理器（33min），为矩阵分配空间，把矩阵元素映射到文件空间中。

然后…接着offset+j的地方，再往后读w-1个数，这样是可行的
但是，判断我们接下来要读的那个数在不在cache里，需要额外的信息
我觉得我们可以维护一个

- 写一个矩阵类。
- 成员函数：
  - 矩阵的长和宽（这个实验中相等）；
  - 一个文件；
  - 一个int指针的cache；
  - cache长度w；
  - 上次读的是哪里，cur。
  - 初始为0的miss count。
- 初始化：
  - 给出矩阵长宽，给出文件名，新建一个文件，把文件里写满乱七八糟的数据。
  - cache=new int[w]；
  - 维护上一次读到的地方，方便起见直接cur=0（反正矩阵乘法），并且读文件、把数据放到cache里、miss count++；
- 读，参数为行 i 列 j，返回读出的值：
  - 应该去`(i*n+j)*sizeof(int)`的地方读。
  - 看看是否有`i*n+j-cur<w`，如果有，直接读cache；
  - 如果没有，去`i*n+j`读文件，并且把后面w个字符搞到cache里，miss count++，更新cur；
- 写（对于矩阵乘法的结果C），参数为行 i 列 j 和写入值：
  - 应该写到`(i*n+j)*sizeof(int)`的地方。
  - 看看是否有`i*n+j-cur<w`，如果有，直接写到cache里；
  - 如果没有，cache的内容写回文件，去`i*n+j`读文件，并且把cache用新内容填满，miss count++，更新cur；

## 二、用快排实现外排序，串行，完善缓冲区管理器

45min。

自己维护内存。

先把middle group填满（用能排序的东西维护）。然后接着读（用input缓冲来加速磁盘访问），维护small large。

然后我们把middle group写回文件。

## 三、归并排序外排序，双端优先队列，败者树，缓冲区（借鉴前面）

57min。

生成初始的有序序列res。把这些序列分层次归并。

设置可用内存的大小。

分层次的两路归并：维护两个输入缓冲区，一个输出缓冲区。

## 四、并行多线程，不同的归并长度如何生成，huffman树得到最佳归并

1h01min。

同一时间：边读磁盘、边写磁盘，边进行内排。线程。

优化初始归并段：原来初始归并段的长度与可用空间一致，现在想把某些段变长一些。

两个input，两个output，其他实现败者树。

大概就是，一个缓冲区干活（提供数据），一个缓冲区读磁盘（补充数据）

print 基于huffman树的最优归并计划，每个归并段的长度。

## 五、并行多线程，归并时处理复杂的缓冲区管理















