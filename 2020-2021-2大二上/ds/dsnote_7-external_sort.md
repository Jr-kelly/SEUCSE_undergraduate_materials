# 外排序

基于磁盘进行的排序多使用归并排序方法；

排序过程主要分为两个阶段：

1. 建立用于外排序的内存缓冲区；

- 将输入文件划分为若干段，用某种内排序方法对各段进行排序；

- 经过排序的段称为初始归并段 (Run)。当它们生成后就被写到外存中去；

2. 按归并树模式，把①生成的初始归并段加以归并，一趟趟扩大归并段和减少归并段数，直到最后归并成一个大归并段为止；

归并趟数$S＝\lceil log_km\rceil$=树高-1；

增大归并路数，可减少归并趟数，减少总读写磁盘次数d；

## k-路平衡归并

补全正则树，补u个归并段：
$$
ke_k+1=e_0+e_k\\
e_k=\frac{e_0-1}{k-1}\\
u=k-1-(e_0-1)\%(k-1)
$$
如果归并时简单比较，增大归并路数k会使内部归并的时间增大。

所以引入败者树：

### 败者树

叶结点：存放各归并段在归并过程中当前参加比较的记录；

非叶结点：记忆它左右子树中的”失败者“；

让胜者往上继续进行比较，一直到根结点；

自底向上调整败者树，选出最小的记录只需比较$\lceil log_2k\rceil$次；

归并趟数$S＝\lceil log_km\rceil$；

所以内归并总时间为$log_2m$，与k无关；

归并路数 k 不是越大越好：

归并路数 k 增大，相应需增加输入缓冲区个数。如果可供使用的内存空间不变，势必要减少每个输入缓冲区的容量，使内外存交换数据的次数增大；

## 生成更长的初始归并段

利用败者树：

若新进的元素key小于loser[0].key，则其段号为loser[0].段号+1；

比较：先比段号越小越好，再比key越小越好；

没有新进元素时就进一个虚段号元素；

输出虚段号元素代表生成结束；

每输出一个记录，对败者树进行调整需要时间为$o(log_2 k)$；

生成初始归并段的时间开销是$o(nlog_2 k)$；

## 最佳归并树

希望带权路径长度最小：总的读写次数达到最少；

为使其正则，要补一些0归并段；


$$
——the~end——\\
冲啊！
$$



