# 3-4章的笔记

## 栈 Stack

overflowProcess：有可能考；

E \*newArray = new E[2*maxSize];

然后深复制；

双栈共享一个栈空间；

进栈序列编号为1，2，3，…，n时，出栈序列的可能情况有cn种；卡特兰数；

枚举栈空前最后一个出栈的元素；

1：1；2：12，21；
$$
C(n)=\frac{C_{2n}^n}{n+1}
$$

### 栈的应用：表达式求值 Evaluation of Expressions

前缀：操作符缀在前面；中缀；后缀；操作数顺序不变；

#### 中缀转前缀：

对中缀表达式按运算优先次序加上括号；

以就近移动为原则，把操作符后移到括号的前面；

移一个消一个括号；

严肃地写程序：其实是先写了后缀，前缀从网上找一个做法，记得正确性还可以：

| 操作符  | ;    | (    | *, /, % | +, - | )    |
| ------- | ---- | ---- | ------- | ---- | ---- |
| isp栈内 | 0    | 6    | 5       | 3    | 1    |
| icp栈外 | 0    | 1    | 4       | 2    | 6    |

(1) 初始化两个栈：运算符栈S1 和 储存中间结果的栈S2；

(2) **从右至左**扫描中缀表达式；**倒序**扫描；

(3) 遇到操作数时，将其压入S2；

(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：

​	(4-1) 若 该运算符ch的栈外优先级icp 大于 栈顶运算符op的优先级isp，将运算符压入S1；

​	(4-2) 若相等（即括号配对），将S1栈顶的运算符弹出，再次转到(4-1)与S1中新的栈顶运算符相比较；

​	(4-3) 若小于，将S1栈顶的运算符弹出并压入S2，再次转到(4-1)与S1中新的栈顶运算符相比较；

(6) 重复步骤(2)至(5)，直到表达式的最左边；

(7) 将S1中剩余的运算符依次弹出并压入S2；

(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。

#### 中缀转后缀：

对中缀表达式按运算优先次序加上括号；

以就近移动为原则，把操作符后移到括号的后面；

移一个消一个括号；

严肃地写程序：考虑操作符优先级，用栈实现；

| 操作符  | ;    | (    | *, /, % | +, - | )    |
| ------- | ---- | ---- | ------- | ---- | ---- |
| isp栈内 | 0    | 1    | 5       | 3    | 6    |
| icp栈外 | 0    | 6    | 4       | 2    | 1    |

in stack priority; in coming priority;

操作符优先数相等的情况：只出现在括号配对 或 栈底的“ ;”号与输入流最后的“ ;”号配对时。

栈底有个；，输入流最后有个；。曾经错在约定上；

步骤：

- 初始化栈，入栈";"；
- 读入：若操作数直接输出；
- 操作符，判断 读入的ch的优先级icp 和 位于栈顶的操作符op的优先级isp；
- 若读入的优先级更大，则入栈；
- 否则while读入的优先级小于等于栈顶优先级，弹栈；
- 上一步中，若读入的优先级小于栈顶优先级，输出弹出的top op；
- 否则就是括号成对，不要输出；

#### 后缀表达式求值 & 前缀表达式求值：

后缀：读数，读到op：pop，pop，运算，push；

前缀：读操作，读数1计数，读数2：pop，pop，运算，push，计数=1；应该是吧；

#### 中缀表达式求值：

建立并初始化OP栈（操作符）和OPD栈（操作数），然后在OP栈中压入一个“;”

扫描中缀表达式，取一字符送入ch；

当ch != ‘;’ 或OP栈的栈顶 != ‘;’时, 执行以下工作, 否则结束算法；

若ch是操作数，进OPD栈，从中缀表达式取下一字符送入ch；

若ch是操作符，比较icp(ch)的优先级和isp(OP) 的优先级：（这里的isp和icp用的是中缀转后缀那个

若icp(ch) > isp(OP)，则ch进OP栈，从中缀表达式取下一字符送入ch；

若icp(ch) < isp(OP)，则从OPD栈退出a2和 a1，从OP栈退出θ, 形成运算指令 (a1)θ(a2) ，结果进OPD栈；

若icp(ch) == isp(OP) 且ch == ')'，则从 OP栈退出'('，对消括号，然后从中缀表达式取下一字符送入ch；

### 栈的应用：递归

单向递归和尾递归可以直接迭代，剩下可以用栈；

#### Rat In A Maze：

Backtrack：回溯；

用栈记录路径；

## 队列 Queue

### 循环队列

队头指针进1: front = (front+1) % maxSize；

队尾指针进1: rear = (rear+1) % maxSize；

队列初始化：front = rear = 0；

队空条件：front == rear；

队满条件：(rear+1) % maxSize == front；

注意！！front是pop的地方，从队尾rear插入；也就是在单向队列里，rear>front；

### 队列的应用：打印杨辉三角形 Pascal's triangle

从第 i 行数据计算并存放第 i+1 行数据：

1 1

1 2 1

1 3 3 1

1 4 6 4 1

```cpp
q.push(1),q.push(1);
for(int t=0;t<times;++t){//times是行数-1，也就是除第一行1 1新打印的行数
    q.push(1);int t=q.pop(),s;
    for(int i=0;i<t+1;++i){
        s=t,t=q.pop();print(s);
        q.push(s+t);
    }
    q.push(1);cout<<endl;
}
```

### 优先队列 Priority Queue

插入排序思想维护；

其实堆也可以的；

### 双端队列 Deque

在队列的两端进行插入和删除；
$$
嗯。大概这样。\\
其实我时间完全不够了。下一步是以题代学。\\
加油加油冲冲冲。
$$

啊，刚刚发现还有链表！！！我爆炸。

## 链表 Linked list

### Single Linked List with first pointer (带表头结点的单链表)

为什么带表头？

统一空表与非空表的操作，简化链表操作的实现；

### 多项式！Polynomial

#### 表示

链式存储：coef+exp+link；

应该会带个表头？

#### 加法

检测指针pa和pb分别指示两个链表当前检测结点；

设结果多项式的表头指针为C；

存放指针为pc，初始位置在C的表头结点；

当pa和pb没有检测完各自的链表时，比较当前检测结点的指数域：

- 指数不等：小者加入C链，相应检测指针pa或者 pb进1；
- 指数相等：对应项系数相加。**若相加结果不为零**，则结果加入C链，pa与pb进1。

当pa或pb指针中有一个为NULL，则把另一个链表 的剩余部分加入到C链。

### 循环链表应用：约瑟夫Josephus问题

好像就，简单模拟？

广义表，真希望不考。

### 写一遍双向链表插入删除

```cpp
void insert(node* p,node* pre){
    pre->next->last=p;p->next=pre->next;
    p->last=pre;pre->next=p;
}
void remove(node* p){
    p->next->last=p->last;p->last->next-p->next;delete p;
}
```

$$
应该算是看完了吧。下一步会做题哦！\\
加油加油冲冲冲。
$$


















