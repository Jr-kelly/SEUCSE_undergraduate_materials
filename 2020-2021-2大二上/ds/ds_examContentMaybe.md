# 老师上课讲的可能考的内容

## 题型

选择10道题，1题2分；

简答6题，1题10分；

编程3选2，1题10分；

会有难题，把小知识点串联起来，分解解题；

## 可能的考点

算法 复杂度；

**数组、栈、队列的特征**和应用角度；

**栈算表达式一定会考的。**前缀后缀转换，等价性；

### 栈算表达式：

#### 中转后：

isp与icp：

|         | ;    | (    | +, - | *, /, % | )    |
| ------- | ---- | ---- | ---- | ------- | ---- |
| isp栈内 | 0    | 1    | 3    | 5       | 6    |
| icp栈外 | 0    | 6    | 2    | 4       | 1    |

嗯，对的。

从左到右扫描输入序列，遇opd直接输出，遇op与栈顶比较；

若icp(op)>isp(top)，则入栈；

否则输出top且pop，直到小于；

如果遇到等于，那就是一对括号，直接pop不输出；

#### 中转前：

把括号的ispicp换一下；

然后从右到左（倒着）扫描输入，遇opd进OPD栈，遇op与OP栈顶比较；

若icp(op)>isp(OP的top)，入栈；

否则输出top，把OP的top入栈到OPD，popOP；

等于还是括号成对；

最后把OPD栈的内容一个一个pop输出；

#### 算中缀表达式：

两个栈，OP和OPD；

操作数进OPD；

操作符按照中转后那一套操作；icpisp按照中转后；

若操作符能入栈则入栈；

若不能即会pop操作符的话，记pop的那个叫θ，从OPD栈pop两个数，算两个数θ操作的结果再push到OPD里。

push的结果是 (后出)θ(先出)；

### 队列会考循环队列和双向队列；

zjl：为什么用循环队列，原来有什么问题，循环有什么好处？

循环队列可以充分利用空间，并且入队出队的时间复杂度不变；

猜测考双向队列补全程序什么的或者让我实现一个。

### 从二叉树Traversal反推二叉树；

递归；

二叉树应用：排序二叉树（不知道指的是不是堆），BST，AVL，Huffman；

### 森林与二叉树的转换，森林的遍历；

先根先序，后根后序，层次序和二叉树是两回事。

二叉树：lch是子树们的二叉树，rch是剩下树们的二叉树；

### 图Traversal与树Traversal的关系！

对二叉树用bfs，就是层次序遍历；

对二叉树用dfs，是先序遍历；

若dfs时访问完前路上的节点再访问根节点，就是后序遍历；

### 图Traversal：

zjl：在不同的表下面：加/删除点/边，遍历；

#### MST: prim, kruskal;

prim和kruskal的时间复杂度都是是eloge；

#### Shortest Path: Floyd, dijkstra, Bellman-Ford;

dijk不能有负权边，时间复杂度是n^2；Floyd O(n^3)；

Bellman-Ford是O(V*E)；就是外层循环V次OV，然后内层对每一个边松弛一次OE；

##### dijk模拟时答题格式：

迭代次数，已确定最短路的节点集合，path[v]表示v最短路的前驱, dist[v]表示最短路长度；

实现的时候，对每个加入确定集合的顶点的边重新看一遍dist，然后对所有dist取最小，再加入集合一个顶点……

#### AOV: Topological Order; AOE: critical path;

Ve(i)：事件Vi （顶点）的最早可能开始时间，是从源点V0 到顶点Vi 的最长路径长度。

Vl[i]：事件Vi 的最迟允许开始时间。

e[k]：活动（边）ak (k=<i,j>) 的最早可能开始时间，是从 源点V0 到 顶点Vi 的最长路径长度。e[k] = Ve[i]；

l[k]：活动ak 的最迟允许开始时间，l[k] = Vl[j] - dur(<i,j>) 其中, dur(<i,j>)是完成 ak 所需的时间。

l[k]-e[k]：时间余量，最迟-最早，==0为关键活动。

### 查找：

BST，AVL，B，B+，hash；插入删除，hash解决冲突；

zjl：一步步插入和删除的过程；

### 排序：稳定性，复杂度，内排序；

插入：直接插入排序稳定，二分插入排序稳定，**shell sort不稳定**！

交换：冒泡稳定，快排不稳定；

选择：直接选择排序不稳定，堆排序也不稳定；选择排序都不稳定；

基数排序稳定！归并排序稳定！

外排序貌似不是重点；

### 串：KMP，要写明next的定义！！！

next定义：当模式中下标为j的字符失配时，应该从next[j]再开始匹配；

即 a0...ak = aj-k...aj-1 的max k再+1。

### 算法的正确性！

#### 最短路：dijk；

假设**S**为已经求出的最短路径顶点的集合，而**V**是还未求出的最短路径的顶点的集合。

现用**数学归纳法**证明算法正确性：

1.已知当S中除了源点V0只有一个点v1时，可以证明V0到V1的路径一定是最短的。反证法证明：假设V0到V1的距离不是最短的，那么必定存在一个点Vx，有路径(V0,Vx,V1)是最短的。但这是不可能的，因为根据算法如果(V0,Vx,V1)的路径比(V0,V1)路径要短，那么算法就会选择x加入S中，而不会选择V1，这与已知条件矛盾，故假设不成立。嗯，看懂了！

2.现证明当S除源点外有n个点，当加入除源点的第n+1个点即Vn+1时，源点V0到Vn+1的路径是最短路径，算法正确性即可得证。嗯，是！

3.根据假设条件，当前源点到顶点Vn,Vn+1 以及 V中剩余顶点 的 最短路径为D[n]。根据算法，当加入第n+1个顶点时，源点到Vn+1的最短路径只有两种可能：(V0,Vn+1)或者(V0,Vn,Vn+1)，即它的长度要么是V0到Vn+1的弧上的权值（是不是就是原来路径的意思），要么是D[n]和从Vn到Vn+1的弧上权值之和（源点到Vn路径+Vn与Vn+1连边的权值），可以证明得到的路径一定是最短的。

反证法证明：假设 **V0到Vn+1的最短路径** 上有一个顶点不在S中（这句话暗示目前得到的Vn+1最短路径是 **利用 S中顶点 所能得到的最短路径**，但这是为什么呢？），则说明存在一条最短路径的终点（就是那个顶点，这里需要无负权值边的性质）不在S而长度比此路径要短。但这是不可能的，因为算法是按路径长度递增的次序来产生各最短路径的，故长度比此路径短的所有路径均已产生，它们的终点肯定在S中，即假设不成立。

证明：目前得到的Vn+1最短路径是 **利用 S中顶点 所能得到的最短路径**，即只利用S中顶点无法得到更短的路径。

数归。假设Vn及以前的顶点都确定了全局的最短路径。只利用S中（Vn及以前）顶点，那最短路径肯定是min dist[Vi]+d(Vi,Vn+1)；

对于每一个与Vn+1邻接的Vi，在前n趟都已经查看过了，因此是最优了吧。

4.Dijkstra算法正确性得证。

#### KMP；

zjl：

假设利用next计算遗漏了一个解，那么可以反证得到next[j]不是0到j-1的最大子串长度。

（这里是长度哈，因为pattern里面0到k（k+1个字符）是那个首尾相同子串，所以+1后不-1就是长度了。

画图说明，不是很难想；



















