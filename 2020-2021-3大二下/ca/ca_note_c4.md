# ca第四章 指令级并行技术

## 动态调度

指令级并行，instruction level parallelism，ILP；

ILP：基本块内并行性，跨基本块并行性，前者性能不如后者；

基本块：由顺序型指令组成，中途无转入点；

程序顺序：源程序串行方式下指令执行顺序；

执行顺序：只要与程序顺序结果相同就行了。

静态调度：编译器编译时；动态调度：硬件执行时；

### 基本思想

把ID分成【IS发射，结构冒险】+【OF取数，数据冒险】（不涉及控制冒险

操作数就绪的指令优先通过OF段；

RAW先写后读：等你写好才能读，我希望读新值；

WAR先读后写：先读完你才能写，我希望读旧值；

WAW写写：我们写的顺序不要乱掉；

要求：指令窗口保存指令，推迟异常产生（该它执行（而不是现在乱序的顺序）时异常才产生，不是精确异常（要求机器状态和顺序执行时一样））

优化：设置多个时延不同的EX，多条指令同时执行（性能提升关键）；

### 记分牌

每个部件只能存放一条指令。若部件被占，则迟迟不能IS（指令进入记分牌）。

![image-20210419114508141](.\..\..\typora-user-images\image-20210419114508141.png)

![image-20210419114350338](.\..\..\typora-user-images\image-20210419114350338.png)

一行DEV表：

- 这个部件是否被占用Bs；
- 它要做什么操作Oper；
- 从哪里取opd/算完之后放在哪FiFjFk，是否把源opd取回来RjRk（取回来/不能取0，能取但还未取回来1，要防WAR先读后写）；
- 如果源opd没取回来那么去哪里取QjQk。

RF表：是否即将被写Bs，被什么部件写Qi，现在的值是多少。RF就是寄存器组。

或许会有一个指令窗口，一行的内容是指令地址（PC）+指令状态。不清楚。

要等所有opd都就绪，然后再用一个时钟周期取opd；OF专门1周期！

![image-20210419114452364](.\..\..\typora-user-images\image-20210419114452364.png)

先写后读：等它写，指令阻塞在IS，迟迟不能EX。

先读后写：等它读，指令阻塞在WB。

写写：阻塞到IS段。

请去写ppt的例题吧！

### tomasulo

与记分牌不同，存放指令不受部件个数限制。只有RS/FLB/SDB满，IS才会阻塞。

![image-20210419114528571](.\..\..\typora-user-images\image-20210419114528571.png)

![image-20210419114545395](.\..\..\typora-user-images\image-20210419114545395.png)

分布式动态调度。

按照功能/使用部件分离的指令窗口：RS、FLB、SDB。

SDB：EX段计算访存地址，WB段访存。

请去写ppt的例题吧！

## 动态分支预测

预测转移方向（是否转移+目标地址），并直接执行该方向指令。

猜对时继续执行后续指令，分支指令不写PC。

猜错时回头（清空流水线+重写PC）执行反方向指令。

分支预测算法：静态 & 动态。

静态预测：定向预测IF（不转移）、按指令内容预测ID（CALL/RET/JMP转移，相对寻址偏移量负转移、偏移量正不转移，非相对寻址不转移）。

转移历史管理：用什么硬件保存，按什么格式管理。

预测处理流程：预测、更新、误预测处理。

### 饱和计数预测器

![image-20210510121000008](.\..\..\typora-user-images\image-20210510121000008.png)

分支历史表BHT，像cache。PC对指令地址相联查找，若查到就预测出转移方向，但是没有记录转移地址。

分支目标缓冲器BTB，同时记录转移地址。信息的建立和更新。

#### 转移历史管理

有效位V+标记tag（PC的一部分，组相联）+一些管理信息（LRU之类）+转移历史+分支目标地址。

BTB缺失、结果为转移时：建立新行，转移历史<-11。

### 其他预测器

相关预测器：2级预测器。用其他分支的行为预测当前分钟。

预测器含m为全局历史，(2^m)*n位模式历史。

- 用PC对预测器进行相联查找。
- 同时，根据前m个分支的行为（全局历史），选择预测器（用全局历史作为MUX的输入）。
- 根据所选预测器的模式历史，预测转移方向。
- 根据执行结果，更新全局历史（移位寄存器）、模式历史（状态转移图）。

Tournament：全局预测器+局部预测器，当前用哪一个由选择器决定。

### 预测处理流程

预测：

- IF查BTB，命中进行预测（按照首位决定是否转移），否则PC+1。
- ID静态预测，判断是否为BTB缺失的分支指令。

更新：EX根据执行结果，建立/更新转移历史。

误预测：恢复现场（清空流水线），重置PC（反方向）。

![image-20210512094527273](.\..\..\typora-user-images\image-20210512094527273.png)

取完指接着置nextPC。

### 性能分析

IF预测正确：停0拍；ID预测正确：停1拍；

IFID预测错误：停（阻塞法+1）拍。3+1=4拍？？好像是。

性能优化：BTB设置分支目标指令域（1~2条指令），减少回头延迟？感觉会存放两个方向的指令内容。

设置返回地址缓冲器（RET，返回地址可变），RET指令不进入BTB，ID时取返回地址。这个缓冲器是栈吗，遇到CALL就压栈？

## 基于硬件的推测执行技术

动态分支预测选择后继指令+动态调度处理数据冒险+控制冒险消除前直接执行后继指令。

按序确认后写结果，推迟异常产生。

### 硬件结构

增设分支目标缓冲器BTB、确认段RET、再定序缓冲器ROB（不保存源opd的指令窗口，SDB和临时FLR）。

IF-IS-EX(OF)-WB-RET。

WB：结果写入ROB。其实是发送到CDB、FLB/RS/ROB自己收数据。

RET：

非分支指令：结果写入REG/MEM，释放ROB行（SDB的写入）。

预测正确的分支指令：释放ROB行，不写PC。

预测错误的分支指令：清空ROB/RS/FLB/段间reg，PC置为反方向。



### ROB

按序（循环队列，头尾指针）保存所有指令的结果和状态。

![image-20210513205714554](.\..\..\typora-user-images\image-20210513205714554.png)

用ROB项号代替RS/FLB站号，RS/FLB不需要有站号了。ROB项号从1开始！



## 多指令流出技术

一个时钟周期完成多条指令。

发射与流出：发往EX段，从EX段输出，都是issue。

发射条件：无结构冒险，或许无数据冒险。

发射/流出：按序/乱序。

### 超标量技术

IS阻塞：与当前指令以及前驱指令有冒险的指令，和它后续的所有指令。

IS发射：无冒险的连续指令。

PII CPU，12个段的超标量流水线。

### VILW

超长指令字，very long instruction word。

主要是软件技术：编译程序生成代码时，消除所有冒险。

静态发射，每个Tc发射的指令数固定。静态调度。

锁步：EX时延=max{各个小指令段操作时延}，保证同进同出。

### 其他软件技术

循环体展开（使用reg数量增多）；

## 多线程技术

TLP，thread level parallelism，不同线程指令相互独立。

MT，multithreading，多线程技术。

多处理器技术，基于单处理器的多线程技术。

多个线程以重叠方式共享单处理器的功能部件。

一套功能部件：线程共享，多套状态部件：线程私有。

context switch时，线程状态保存在主存。

### MT实现方法

都是2个线程。

细粒度：每个时钟周期切换线程，时间片轮转法。吞吐率提高（隐藏一些停顿），单个线程速度变慢。对两个线程，按ROB项号奇偶区分线程。

粗粒度：有较长停顿λ时切换线程。吞吐率提高有限。若停顿<λ，则没有效果。

同时MT，SMT，超线程MT：同时执行不同线程的指令，执行th1的访存和th2的乘法，充分利用功能部件。优先线程+时间片轮转。

![image-20210513213530837](.\..\..\typora-user-images\image-20210513213530837.png)



# 例题

## 判断

保持异常行为并不是精确异常。好像是，保持异常行为只是当指令应该被执行时产生异常，不产生新的异常。精确异常要求产生异常时程序状态和顺序执行时一样。

记分牌/Tomasulo什么时候可以指令流出，xxx条件（代码+机器状态）下可以流出吗？

ROB项号从1开始！

## 大题

模拟记分牌/tomasulo/speculation。

写保留站状态，计算序列执行时间。



不知道有没有PII的12段超标量流水线。