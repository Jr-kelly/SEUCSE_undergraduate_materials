现在已经尝试过的思路：

floyd：

最原始的思路，用floyd处理任意两点之间最短路，权值用原始权值。800。



dijk：

对每一个请求都算dijk，每次更新权值。相当于一个一个处理请求。600。



一簇一簇的floyd：

分成大概144的小簇，对每一簇跑floyd，跑完更新权值。460。



一簇一簇的dijk：

为规避栈，交换了navi的source/destiny，并对edge编号/alpha进行交换。

根据出发点分簇，对每一簇跑dijk，修改边权。可以跑3遍，此时还有很多时间。

420。



两遍的floyd：

分成350的簇，对每一簇跑floyd，权值更新*1.3，权值不减小，跑两遍。420。



floyd模拟：

目前的soa。



簇状dijk+模拟：

3遍簇状dijk后开始模拟（权值减回去），性能不升反降，大概450。当ALL_TIMES=TIMES=3时，420（原来的簇dijk）。



簇状dijk+部分更新：

从第二次开始，只对一部分navi跑dijk。520。



下一步的想法：

用一簇一簇的dijk得到预处理的路径（此时时间仅过去1/5），然后继续处理。







13，0.5：420

6，0.5：423

3轮，6，0.5：411

4，6，0.5：410

4，5，0.5：411

5，6，0.5：413

5，6，1：457

4，6，0.7：411

5，6，0.7：409

5，6，0.3：420

5，6，(TIMES-times)*0.3：414

5，6，times*0.3：411

5，6，times*0.5：负环，RE

5，6，times*0.2：414

5，6，1/times：415

5，6，1/times*0.7：420

4，6，1/times：413





5，6，0.68：40935

5，6，0.69：4095

5，6，0.7：4093

5，6，0.71：4094

5，6，0.72：4099

5，6，0.75：410



4，6，0.7：411

5，6，0.7：409

4，5，0.7：413

4，7，0.7：411









